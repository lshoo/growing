> # 编程之道

> ## 编程思维

    1.  编程过程体现的思维，其核心不是编程语言，也不是语法，甚至不是算法或数据结构本身，
        而是如何分解问题，从中发现规律（抽象），建立解决问题的模型，并映射到合适的数据
        结构和算法上，然后才能根据数据结构和算法写程序实现。
    
    2.  对于程序员来说，编程和功能实现并不是“最重要”的的工作，越是高级的
        程序员，编程所占日常工作的比例越低，最重要的工作发现问题，发现规律并抽象模型，
        为其找出解决方案。
    
    3.  程序员的日常除了编程，还有
        *   Peer Review: 主要负责 review 同事们的代码，以及日常交流的反馈。
            一般每天都能收到别人的 code review，在年底的时候会收到general review。
            Manager Review主要是去 review 自己的 manager。指出做得好的地方，自己得到帮助的地方；
            顺便也列几条需要改进的地方。例如看看有没有 micromanagement 以及可能的影响日常工作效率的问题。   
        *   Mentoring & Teaching：这个是指把自己知道的知识分享出去，让新来的同事快速上路、提升工作效率。
            或者经常在团队里和大家分享新的东西，例如学习心得、行业动态等。总体来讲包括但不限于编程，
            更多的是 domain knowledge、流程，团队建设等相关。
        *   Company-wise Contribution：有很多可以贡献的地方，最经典的就是面试。经常主动、高质量地去
            完成面试，帮公司找到更优秀的人才，对于哪个公司应该都是第一要务。
            
    4.  从来都不存在如何学好编程这件事，有的只是如何能成为一名好的程序员，和如何学会学习
        这是因为编程作为把思维变为实现的这个循环的最后一步(然后写好的程序会成为新的思考输入和基础，开始新
        的一轮迭代开发)，它和一个项目一个系统的<font color=red size=6>所有其他方面</font>都息息相关：
        需求获取，问题抽象，测试，监控，部署，框架运用，系统间集成，灵活性，未来拓展性，易用性，系统健壮性，
        多版本实验性，高层业务决策等等，这使得编程变得无比重要(所有的一切都需要编程来最终落到实地)，也毫不
        重要(编程被所有其他一切所约束和指导)。能够支撑这些所有上层思考的程序才是“好程序”，能够支撑所有这些
        思考的程序员，才是好程序员。学好/学会编程这件事是把所有需要思考的东西都弄明白都学好之后的自然结果。
        而把这些思考留给别人，自己只做思维和程序的翻译器，根本无法写出好的程序来。这也是DDD(Domain Driven
         Design) 的精神之一 
         
    5.  语言是思维组织和推演的工具，语言会大大影响思维。

> ### 程序员的能力

#### 编程能力 

    就是用代码解决问题的能力。你编程能力越强，就能解决越复杂的问题，细分之下，要有调试能力、算法、数据结构、
    操作系统原理等基础技能的支撑，你才能解决各种麻烦的问题

#### 架构能力
    
    就是掌控复杂系统的能力。当一个系统足够复杂时，你会写每一块代码、能解决每一个问题，不等于你能搞定整个系统，
    这就需要架构能力。架构能力包含了一些意识，也包含认识业务建立抽象模型，还有一些常见的模式等    
 
#### 工程能力

    其实核心就是成事的能力。你要知道，当系统规模越来越大时，光靠你一个人是没办法完成的。那如何保证几个高手能够
    互相配合好？如何保证项目里面水平最差的人不拖后腿？工程化建设往往会跨越多个业务，又如何保证质量和代码风格呢？
    
    编程的”工程性难点”就是，你如何在这错综复杂的耦合中，在复杂性不断增加的过程中，如何让软件有序，规范地”进化“，
    而不是让其肆意疯长，最后成为一坨无人能懂，无人敢碰的”屎山“。
    
#### 团队协作
    
    文档，规范化，标准化的代码编写习惯

#### 沟通能力

#### 持续学习
     
> ## 软件工程

    
> ### 软件工程定义

    软件工程设计具体指程序员预计以怎样的方式实现具体功能，包括
    *   功能模块的划分 
    *   单元测试和集成测试分析
    *   哪些可以使用已有的lib，使用场景的调研
    *   对于新增的模块，具体实现方案，包括用到哪些设计模式，UML图，C4 Model，数据库Schema等
    *   和其他team的衔接，定义API及调用方式，或消息队列和TOPIC
    *   Stakeholders和资深或高级开发人员充分沟通业务目标，并绘制影响力地图
    *   草拟产品里程碑和交付计划，效果跟踪，循环迭代
    *   多方沟通交流（Stakeholder，产品，项目经理，开发，测试，运维，架构）
    *   小团队内部例会（早会，周会，月会），探讨团队重点开发目标，支持场景，未来规划等
    
    
> ### Code Reviews
    代码审查的一般目的是让开发团队在代码投入生产之前就识别并纠正错误。这是传统观点。但是，代码审查
    不仅可以实现上述的结果，还可以完成更多的工作-尤其是当领导者和经理成为审查过程中有意义的参与者时。
    除了修复错误外，代码审查（可以交替使用PR，pull request和代码审查）这两个词可以带来更高质量的
    代码，从而使整个团队更加了解。
    研究表明，此过程不仅节省了成本，还减少了对质量保证的依赖，并且除了代码质量外，还改善了工程开发，
    知识共享以及团队的整体文化。
    这也是工程师进行合作，向同行学习，实践指导以及发现问题的改进解决方案的机会。
    

> ### 高效程序的七个习惯

    1.  学会阅读他人的代码
    2.  能够感知糟糕的项目
    3.  少开会
    4.  Github
    5.  编写简洁可维护的代码
    6.  学会说“不”，分清轻重缓急
    7.  面向可操作的设计思维
    
> ### 算法、人与计算机

    算法的难主要集中在两点, 一种是算法的构思和提出, 一种是提出算法之后, 用code实现出来。
    算法的构思和提出最为困难，因为这部分经常要求我们将我们眼中“显然”的东西，转换成计算机语言。
    比如现在要实现一个算法，这个算法能够识别一张图片，判断图片中是否有人脸，对于人类来讲，这是不经思索的，
    一眼就能看出来的，但是问题是，你自己也不知道你自己是怎么看出来的，这个判断过程，其实我们的大脑内部发生
    了很复杂的化学反应，但是我们却说不清，我们到底是怎么判断的，还比如判断人脸的情绪等等。
    
    现在要实现一个算法，这个算法能够识别一张图片，判断图片中是否有人脸，对于人类来讲，这是不经思索的，
    一眼就能看出来的，但是问题是，你自己也不知道你自己是怎么看出来的，这个判断过程，其实我们的大脑内部
    发生了很复杂的化学反应，但是我们却说不清，我们到底是怎么判断的，还比如判断人脸的情绪等等。
    
    但有人说，这说明计算机比人笨，事实上完全不是这样，计算机从来就不比人笨，事实上比起人类能做到的事计
    算机做不到，计算机能做到人类做不到的事反而更多。
    
    计算机的特点就是容错率低，但是可预测性强，确定的代码和输入就能得到确定的结果和输出。
    
    人类的特点是容错率高，但是可预测性差，对一个东西的执行结果经常受情绪，身体状况，心态等的影响，结果
    常常是不确定的。
    
    所以其实，一个系统的”容错率“和”可预测性”是个永远不可调和的矛盾，一个编程语言如果具有一定的容错率，
    看起来好像编程更为容易，实际上反而是灾难，bug更难发现，问题更难复现，一个运行正常的系统很有可能有
    一天脑子一抽输出一个错误结果, 这就是为什么几乎所有语言都有异常抛出机制, 就是为了降低容错率。
    
    所以我们要注意一点就是，编程困难，并不是因为计算机不够先进，不够智能，而是我们为了“可预测性”，心甘
    情愿地接受了这种极低的“容错率”，这直接导致你写程序，少打一个分号，编译错误，打错一个变量名，编译错
    误，数组越界，编译错误。
    
    容错性这么低，你还指望它能接受人类这种模糊的自然语言？当然不可能了，所以它一定有自己的，语义清晰的语言。
    
    一个语言一旦语义清晰了，语言灰度底了，它一定是逻辑性很强的，或者说，我们其实是用逻辑写代码，而不是用
    “感觉”或是“情感”写代码，这和我们人类理解世界的方式本来就是有区别的。
    
    人类虽然有逻辑思维的能力，但是逻辑思维从来就不是人脑的强项，人脑的强项其实是整体感知，和一些“系统预设”
    的功能，比如你眼睛睁开了，投入你视网膜的光就会自动的转换成图像信息被你感知，这个过程你调用了任何逻辑
    思维了吗？你几乎什么感觉都没有就完成了一个极其复杂的过程。
    
    所以我们的大脑绝大多数复杂的进程，或者说运行过程，都不能被我们逻辑性地去感知，比如你听到一首歌，这首歌
    给你一种很舒缓的感觉，你说你听着这首歌仿佛进入了一片天灵之地，但是这个过程，请问你进行了任何逻辑思维没有？
    
    你就是感觉了一下而已，但是我们想让机器去做这样的“感知”，因为计算机体系的极低容错性，我们必须用我们的
    逻辑思维搞明白，这首歌，究竟是因为什么，它有什么样的特质，才导致了它给你这样的舒缓感觉，这样你才可能
    把这个过程转换成计算机语言输入到计算机中，让计算机去判断这首歌是“舒缓的“还是”狂野的“。   
    
    所以总结一下编程在算法上的难，就是：
    
    人类这种容错率高，可预测性差的生命，非要逼着自己去和一个容错率低的，可预测性强的这样一种”硅基生命“交流，
    不得不逼着自己用逻辑性很强的语言去和他交流, 在这个过程中我们不得不打破我们原有的感觉和感知, 对其进行
    逻辑解构, 这样才能让跨物种交流得以实现.
    
    看到这里，你一明白了，要想让两种不同的生物更好的交流，要不就是让人类变得更像计算机，要不就是让计算机
    变得更像人。
    
    
> ## 学习

    学习，不仅仅是掌握某些知识点，更重要的是，要发现知识点背后的关联和层次。如果没有对知识构建
    成网，你面对问题领域是不可能有解决思路的。
    
    这里面的关键在于:
    
    知识是有层次和结构的，不是平的。
    
    当你无法发现问题，或者是，无法找到解决方案，这和你的智商没有关系，而是你的知识体系存在缺陷。
    
    善用逻辑思维驱动去学习，而不是死记硬背，这样才能学到可迁移的知识。这个世界上，有80%的知识，
    是由20%的知识产生的。计算机科学的知识也不例外。
    
    读书学习应注意抓住知识间的联系
    
    读书不要在意“记不住”的问题，担心记不住而反复停留在一本书或者一个知识点，是读书的飞轮能否
    转动起来的大忌，真正“有用的东西”会不断重复出现在你眼前。要么工作中需要，要么很火有人提问，
    要么这些知识被同一类的书再次提到，从另一种角度被描述，要么让你感觉“这个东西跟我学过的那个
    有点像”，或者书里写“根据A所以我们有B，然后给个参考链接”… 这些都是在一次加深理解这些知识
    的联系机会。因此，在读书的飞轮里，你不会记不住有用的知识，因为它们会被你反复用到来攻克其
    他的知识难关。当一个知识成为你理解另外n个知识的基础的时候，每当你遇到提到使用到这另外n个
    知识，你都间接复习了这个基础知识，这比反复练习，反复复习来记忆有效率的多。
    
    “知识的真正价值在于知识间的推导/类比/相关/连贯性”。“你自己独特的学习覆盖面将造就独特的你”。
    任何两个人，当他们的知识覆盖面不同，他们对同一个知识的看法也会有千丝万缕的不同的独特理解。
    比如双修DL和PLT，和双修DL和分布式系统的两个人，对DL的看法就会有点不一样。“知识的价值在于
    你懂的知识间，知识与事物间的联系”，这是我们应用知识(去解决问题,或是利用它的去学习更深的知
    识)的关键。
    
    锻炼推理和想象能力，不要强记是什么，而要去理解“为什么”，锻炼用已有的知识，推理出新学的知识
    的能力，让理解水道渠成。锻炼去理解为什么，和正在学习的东西是怎么来的，这件事往往比“记住这个
    知识”更重要，理解新的知识产生的逻辑过程，或者说推理过程，有助于我们修正或者加强自己的逻辑推
    理思考能力；而推理能力越强，把知识联系记忆的几率越高，很多时候我们看书看不懂，是因为我们已
    有的知识和我们正在学的知识之间有一些点我们没有学过，而推理能力越强，则越能正确的脑补出“中间
    的这些点大概应该是怎么样的”，从而最终全盘理解书里的内容。
    
    主动建立你自己的知识网络，让知识关联起来，甚至让你自己的知识起化学反应, 增量你的知识。
   
    用有限的大脑去记录无限的知识
    人的记忆是有限的，就好比电脑有限的内存甚至cpu的cache；很多时候我们只要记住知识索引即可，
    而不必“背课文”。书，资料，文章，都是我们知识数据库的硬盘，而我们只要记住在哪里能找到自己
    曾经理解过的东西，把这些索引知识记录在我们的大脑的cache里即可。
    
    知识是可以触类旁通的，也是可以抽象总结的，这样就使得我们可以记住一些知识的本质，然后很容
    易的在不同应用场景，推理出相关的知识。
    
    当知识可以在你的大脑里形成联系网络，那么即使你忘记了某部分细节，你也可以很容易的利用你的
    其他知识推理出“这里的这个细节理当这样设计”，“由于A，B，C，所以这个D应该是这样来的”，
    “这个问题其实非常的generic，那么一定存在一个库，API可以泛化的解决这个问题”，这样的记忆
    将更佳有效。
    
    锻炼对知识的想象力，对未知的脑补能力。推理和想象能力越强，需要记录的东西就越少。当你理解
    一个东西是怎么来的，那么就算你忘记了它，那么你也可以在需要的时候自己把它推理出来。
    
    让知识自我淘汰
    ##### 知识是否有用，取决于未来。 ######
    
    如果练习的目的是帮助理解，验证猜想，去探索书里没有讲明白的，那么我觉得应该去做。而如果
    练习的目的是记住API，记住细节，那么不建议去做。因为这会拖慢飞轮的转动。
    
    因为：知识是否有用，取决于未来。去强化记忆无用的知识是对时间资源的浪费。
    
    即使不断去学习新的知识，读心的书，真正“有用的东西”会不断重复出现在你眼前 => 从知识的
    海洋中提炼精华，才是我们人类用有限的生命去理解和掌握无限的知识的有效手段。而由于知识的
    联系性，交集性，因果性，会重复看到的的知识，那么一定有一些精髓的地方作为共性，那些知识
    才是最重要的地方。我们要学会保留，会和其他和很多知识起化学反应的知识，和其他知识互为因
    果关系的知识，是学习其他知识的前提的知识。
    
    而当你读书的飞轮转起，你看到的“未来”就比别人多，那么你就更加能用“未来”验证“过去”。
    即在“未来”反复出现的知识，理解“未来”的知识所需要的知识，是珍贵的应该保留的知识。
    
    解耦你的工作和你的学习
    
    很多同学有一个误区是，希望通过做相关的工作来学习相关的知识。这样你的知识就被你的工作，
    你的经历，你的团队，你的项目，你的公司所主导了。你应该根据自己的兴趣主导自己的学习，
    而不是依赖于不受控的东西。
    这样对你的团队也有好处，这样你就不会用项目练手，用过度设计，或者不合适的tools坑害自己
    的项目。
    当然，如果要学习的东西和工作要用到的东西完美契合，那当然是最好的。可惜并不是任何时候
    我们都能找到完美的项目。
    
    自满是自学的大忌
    
    知识爆炸，和知识飞速进化的今天，觉得学会了一点东西就沾沾自喜，觉得比所有不会“这项技术”
    的人强，这将是阻碍自我进步的大忌。因为你往往会爱上你的学的这些知识。。。。
    
    不要爱上你学的技术，带入了感情，就会让判断失去冷静。一个人的toolbox越大，一项技术在
    他的toolbox所占的比率就越小。他就会越博爱而不是偏激的爱上一项技术。对某项技术投入过
    多的感情是眼界太窄的一种体现。
    
    不能用新的自己淘汰旧的自己是很可怕的一件事情，世界进步的这样迅速，不自我杀死，就会被
    别人干掉，而你的知识和技术总会被世界所干掉的。 这样你的知识反而让自己变成了旧世界的
    卫道士，拖累了自己，想想我之前学过的东西: oracle，mysql， SQL调优，activemq，
    aspectJ，enterprise integration pattern，enterprise design pattern，SOA，
    BPEL，camel， QL4j ,naked Object, design pattern，UML，storm，hadoop，hbase，
    hibernate，spring，guice... 如果我只停留在哪里，那么。。。我不敢想。。。
    
    如果你寄希望于用3年掌握一样秘籍，然后吃一辈子。那么你不适合计算机程序这个领域。
    3年所搭建起的优势和壁垒，别人也能用3年搭建起来（甚至别人可以利用后发优势利用更短的
    时间来搭建更好的优势和壁垒），你的知识暂时比别人多这并不是什么优势，利用你的环境，
    利用你已经有的基础，利用你不断锻炼出的触类旁通的能力，归纳总结的能力，来得到高于别人
    的获取知识的速率，这才是你的真正优势，你的飞轮优势。
    
    开阔自己的眼界，才知道自己真的喜欢什么。
    
    计算机领域实在是太博大精深了，所以我建议还没有找清楚方向的同学，不要过多纠结书里的细节，
    多看看不同的领域，先找到自己喜欢的方向 。
    
    当研究到一定广度，就会需要深挖，但是过早地觉得广度几这样了，据造成“过早深入”，甚至为
    细节所累，把生命浪费在琐碎的事情上。不要“过深”，到头来才发现，这根本不是自己喜欢和擅长
    的领域。
    
    注：有些生来就知道自己应该干什么的，知道自己命中注定是要成为XXXX的幸运儿不适用于这个论述
    
    看不懂怎么办
    要做判断，是预备知识已经足够了，自己没有理解，还是由于需要理解当前知识的“预备知识”不足。
    到底应该多读几遍，直到脑补出到底怎么回事？还是思索到死都想不出来？还是let it go，然后
    去看别的。因为很多时候，答案其实就在别的书里。比如很多很多年前我学JMS和ActiveMq的时候，
    我完全不能理解书里宣扬的消息的extact once processing是怎么保证的，知道后来我对分布式
    系统足够了解，这个问题才在DDIA这本书，FLP和End2End Argument的论文里得到解答 => (根本
    不存在什么extact once msg processing，有的只是effective once msg processing)
    
    关键的关键：你可以不记住细节，不记住思路，不记住设计，但一定要记住自己的问题！！！
    
    看书的时候，记住你不懂的东西有时候比你学会的东西更重要。把没理解的东西记在本子里，因为
    这样才不会让解答，在你以后的阅读里滑过你的指尖。而当你通过另外的书理解的你以前读的书。
    两本书的知识就联网了。你很可能对以前的东西更佳融会贯通，也可能用更有效率的方式记住2本书
    的知识，甚至让2本书的知识产生化学反应，生成自己独特的理解。
    
    1书2概念3能力
    
    一本书：Designing Data-Intensive Applications， 对应程序员3能力中的工具箱深度广度
    
    两个概念-1：多范式编程和最小表达力原则(least expressiveness principle), 对应程序员
    3能力中的程序语言理解深度和表达抽象能力
    
    两个概念-2：领域驱动设计(Domain Driven Design)，对应程序员3能力中的方法论，编程大道
    (programming in the big)，和构架能力
    
    
    程序员3能力：
    1. 工具箱广度深度，或者说在技术选型上控制系统复杂度的能力，广度：懂多少数据库/数据处理
    框架/AWS几个重要的Service了解多少/著名的开源软件框架工具了解程度, （这个一年前的答案
    列了一些我们当时经常用的，业界也很流行的，您可以参考下。阿莱克西斯：后端所谓复杂的问题
    是什么？ ） 广度决定了眼界； 深度：为什么数据库要这么实现设计，为什么AWS这个地方有这个
    缺陷（比如SQS为什么是可乱序的queue），看似类似的几个框架，在本质上有什么不同，是在哪个
    本质问题上做了哪些决定行的trade-off导致了它们在设计实现和提供的功能上分道扬镳？ 深度
    决定了能否真的在合适的场景应用合适的能力与工具。
    
    2. 程序语言理解深度和表达抽象能力，这是在实现上控制复杂度的能力，懂不懂得最小表达力原则？
    懂得几种编程范式？它们之间怎么根据具体情况作出取舍？是否知道怎样才能把code写成诗？怎么样
    才能在重重困难中，坚守高聚合，低耦合？怎样组织程序，才能使得让程序正向流动产生期待效果之外，
    程序能否根据效果／结果，倒推并很容易的倒推出这样的一种结果是由什么原因，那个组件造成的
    (这是系统怎么才能很容易进化的关键，也是“做出来就是好的”程序员最难克服的一点)？code写出来
    逻辑线是否清晰可见？阿莱克西斯：编程到底难在哪里？ 
    
    3. 方法论，编程大道(programming in the big)，和构架能力，这是在时间跨度的整体上控制
    复杂度的能力，辨别什么是对的，应该做什么的能力；在时间跨度上，在信息不完整的情况下，现在
    怎么构架，才能使得当将来信息完整了，我们能很轻松的根据将来的正确信息，把系统调整成最好最
    正确的状态，什么决定应该现在做，什么决定可以和怎么样才能留给将来做，并且在这个过程中，保
    证能够支持业务正常运转。
    在整体上，怎么把需求获取/设计/coding/测试/安全/部署/运行监测/报警/性能/系统回馈分析/
    数据统计/报表…等等在全局把握，安排的妥妥当当相互支持而不是相互抵触，相互使绊子。这里包含
    的知识包括，到底是waterfall， TDD，BDD，还是type driven，怎么执行Agile，
    什么是devOps，continuous delivery。 到底应该是技术决定业务，还是业务决定技术？
    给一个100人的团队和超复杂／抽象的需求（比如需求就是让公司业务翻一倍，怎么翻一倍这个抽象
    问题要怎么分解成n个大问题，这n个大问题怎么分解成m个中问题。。。。），怎么把抽象问题落到
    实处，怎么能把大的问题分解成哪怕是比较弱的程序员也可以解决的小问题，然后还要证明这是根据
    现在的信息，可以做出的最好的决定。
    2017年，你看了啥很好的计算机的博客/书/视频？ 这个回答中关于DDD和Clean Architecture的
    介绍讨论了一些这方面的问题您可以看下。
    
    这3个能力有一个相同的关键点，控制复杂度；控制复杂度的能力，是区分程序员能力的关键之一。
    
    一个DDD 实践者经常使用的重要的practise，就是跟PM和客户讨价还价, 学会拒绝和剪裁，
    合理的push back。
    
    因为复杂的技术实现是有代价的，要看换来的业务价值是什么，如果核心逻辑要求一个技术实现，
    关系到项目的成败，那就要不惜代价的去选择完备的实现方案。而当一个超复杂的技术实现只是
    为了一个可有可无的业务功能，那就要强势说服客户PM砍掉这个功能。因为支持这个功能造成系
    统的复杂度，可能会给拓展核心业务造成困难。
    
    简单要大于正确性，因为现在的正确未必是未来的正确，砍掉意义不大的正确性，保持核心的
    简单性，是让核心能够轻装上阵，更好演化的关键。
    
    简单大于一致性，这个很多例子了，大家从事务的强一致行转为prefer 最重一致性就是在
    这点上trade off的最好例子
    
    简单大于功能完备性，这个上边我也解释过了。不需要非核心的功能完备性而牺牲核心或者
    系统的整体简单性。
    
    那么怎么在简单，业务正确性，一致性，完备性里，做合理的trade-off（因为完全不要正确
    性，一致性和完备性也不行呀）就需要对业务有深入的了解认识。程序员的本质还是解决问题
    的人，只是恰巧用计算机来解决问题而已，好的程序员是简化问题和解决问题的高手，他能够
    在业务/技术/人员/文化/复杂度/等等多角度做剪裁，来衡量各种得失，而不是把自己逼死累
    死在复杂的技术实现上，用灵活的手段来让自己的组和公司获得成功。
    
    跳出技术思维的束缚，从全局来思考问题，这就是DDD的精神。